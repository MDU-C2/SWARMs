/*
 * Copyright (c) 2012 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <linux/fb.h>
#include <string.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <termios.h>
#include <stdio.h>
#include <time.h>

#include "hw_base.h"
#include "VDMA.h"
#include "axi_gpio.h"
#include "vasa_udp_client.h"
#include "mem_op.h"

//#include <cv.h>
//#include <highgui.h>

struct termios orig_termios;

void reset_terminal_mode()
{
    tcsetattr(0, TCSANOW, &orig_termios);
}

void set_conio_terminal_mode()
{
    struct termios new_termios;

    /* take two copies - one for now, one for later */
    tcgetattr(0, &orig_termios);
    memcpy(&new_termios, &orig_termios, sizeof(new_termios));

    /* register cleanup handler, and set the new terminal mode */
    atexit(reset_terminal_mode);
    cfmakeraw(&new_termios);
    tcsetattr(0, TCSANOW, &new_termios);
}

int kbhit()
{
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(0, &fds);
    return select(1, &fds, NULL, NULL, &tv);
}

int getch()
{
    int r;
    unsigned char c;
    if ((r = read(0, &c, sizeof(c))) < 0) {
        return r;
    } else {
        return c;
    }
}


int main(int argc, char *argv[])
{
	uint32_t pin_data = 0;
	uint32_t pin_dir = 0x0;

	uint32_t w = 3840; //640;
	uint32_t h = 2748; //240;
//	uint32_t w = 640;
//	uint32_t h = 240;
	uint8_t bpp = 3;

	uint32_t frame_ptr = 0x0; //first fb
	uint32_t frame_ptr_out = 0x0;
	uint8_t cam = 2;
	uint8_t stream = 1;

	uint8_t quit = 0;
	uint8_t update_integration = 0;
	uint8_t dump_image = 0; // 0;

	integration_time_limits_t itl;
	integration_times_t it;

	char filename[15];
	char *filename_ptr = filename;
	uint16_t seq_no = 0;



	if (argc>1)
		switch(atoi(argv[1])) {
		case 0:
			cam = 0;
			printf("Cam0\n");
			break;
		case 1:
			cam = 1;
			printf("Cam1\n");
			break;
		case 2:
			cam = 2;
			printf("Stereo\n");
			break;
		}



//	SetSize(w,h,bpp);
	init_vasa_address(VASA_FV_PORT);
	if (init_vasa_socket_udp () == -1) return -1;

	axi_gpio_init_dir();
	axi_gpio_init_val(&pin_data); //cam i2c high, resets low

	cam_reset(&pin_data);
	init_cams_sync(&pin_data,&pin_dir, SIOD_0, SIOC_0, SIOD_1, SIOC_1);
	fpga_clk_reset(&pin_data);
	usleep(100);
//	getchar();

	get_integration_time_limits(&itl,&pin_data,&pin_dir,SIOD_0,SIOC_0);
	print_integration_time_limits(&itl);
	get_integration_time(&it,&pin_data,&pin_dir,SIOD_0,SIOC_0);
	print_integration_time(&it);

	ResetVDMA(VDMA0_BASEADDR);
	ResetVDMA(VDMA1_BASEADDR);
	ResetVDMA(VDMA2_BASEADDR);
	SetupVDMAs2mm(VDMA0_BASEADDR,w,h,bpp,FB0_ADDR,FB1_ADDR,FB0_ADDR); //only two FP in use
	SetupVDMAs2mm(VDMA1_BASEADDR,w,h,bpp,FB2_ADDR,FB3_ADDR,FB2_ADDR);
	SetupVDMAs2mm(VDMA2_BASEADDR,w/4,h/4,bpp,FB4_ADDR,FB5_ADDR,FB4_ADDR);


	fpga_pipe_reset(&pin_data); //release fgpa soft reset
	sleep(1);


	while (!quit) {


		if (kbhit())
			switch (getch()) { /* consume the character */
			case 'q':
				quit = 1;
				break;
			case 'w':
				dump_image = 1;
				break;
			case 't':
				toggle_cam_stream(&pin_data);
				break;
			case 'a':
				it.coarse += 1000;
				update_integration = 1;
				break;
			case 's':
				it.coarse += 100;
				update_integration = 1;
				break;
			case 'd':
				it.coarse += 10;
				update_integration = 1;
				break;
			case 'f':
				it.coarse += 10;
				update_integration = 1;
				break;
			case 'z':
				it.coarse -= 1000;
				update_integration = 1;
				break;
			case 'x':
				it.coarse -= 100;
				update_integration = 1;
				break;
			case 'c':
				it.coarse -= 10;
				update_integration = 1;
				break;
			case 'v':
				it.coarse -= 1;
				update_integration = 1;
				break;
			}

		if (update_integration) {
			if (it.coarse > itl.coarse_max) {
				printf("WARNING: Coarse integration time > MAX, setting to MAX\n");
				it.coarse = itl.coarse_max;
			}
			if (it.coarse < itl.coarse_min) {
				printf("WARNING: Coarse integration time < MIN, setting to MIN\n");
				it.coarse = itl.coarse_min;
			}
			set_integration_time_dual(&it,&pin_data,&pin_dir,SIOD_0,SIOC_0,SIOD_1,SIOC_1);
			get_integration_time(&it,&pin_data,&pin_dir,SIOD_0,SIOC_0);
			print_integration_time(&it);
			update_integration = 0;
		}


		while (1) { //need to ensure that VDMAs (or actually the first one) are writing to the assigned FB, poll until OK
			read_fp(&frame_ptr_out);
			frame_ptr_out &= 0x3F;
//			printf("frame_ptr_sw: %d %d %d %x\n",(frame_ptr>>12) & 0x3F,(frame_ptr>>6) & 0x3F,frame_ptr & 0x3F, frame_ptr);
//			printf("frame_ptr_hw: %d %d %d %x\n",(frame_ptr_out>>12) & 0x3F,(frame_ptr_out>>6) & 0x3F,frame_ptr_out & 0x3F, frame_ptr_out);
//			printf("\n");
			if (frame_ptr == 0 || frame_ptr == 3)
				if (frame_ptr_out == 0 || frame_ptr_out == 3)
					break;
			if (frame_ptr == 1 || frame_ptr == 2)
				if (frame_ptr_out == 1 || frame_ptr_out == 2)
					break;
		}
//		printf("Frame_ptr check OK!\n");



		if (frame_ptr == 0 || frame_ptr == 3) {
			if (dump_image) {
				seq_no++;
				sprintf(filename_ptr, "0_%d.bmp",seq_no);
				if (cam != 1) SaveImage(FB1_ADDR, filename_ptr, w, h, bpp, 1);
				sprintf(filename_ptr, "1_%d.bmp",seq_no);
				if (cam != 0) SaveImage(FB3_ADDR, filename_ptr, w, h, bpp, 1);
				dump_image = 0;
			}
			if (stream == 1) SendImage(FB5_ADDR, w/4, h/4, bpp);
//			if (stream == 1) SendImage(FB1_ADDR, w, h, bpp);
		}
		else { //--> ptr 1 or 2 --> FB0,2,4
			if (dump_image) {
				seq_no++;
				sprintf(filename_ptr, "0_%d.bmp",seq_no);
				if (cam != 1) SaveImage(FB0_ADDR, filename_ptr, w, h, bpp, 1);
				sprintf(filename_ptr, "1_%d.bmp",seq_no);
				if (cam != 0) SaveImage(FB2_ADDR, filename_ptr, w, h, bpp, 1);
				dump_image = 0;
			}
			if (stream == 1) SendImage(FB4_ADDR, w/4, h/4, bpp);
//			if (stream == 1) SendImage(FB0_ADDR, w, h, bpp);
		}

	toggle_fp(&frame_ptr);

	}


	StopVDMA(VDMA0_BASEADDR);
	StopVDMA(VDMA1_BASEADDR);
	StopVDMA(VDMA2_BASEADDR);

    return 0;
}
